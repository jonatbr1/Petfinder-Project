import requests
import hashlib
import sqlite3
import csv
import pdb # Used for debugging
from lxml import etree

# Function to create a table from a CSV
def create_table(filename, tablename, con, cur):
    #'/Users/jonathan.braus/Desktop/zip_code_database.csv'
    with open(filename, 'rt') as file:
        reader = csv.reader(file)
        header = next(reader)
        data = []
        for row  in reader:
            data.append(row)

    cols = ''
    for col in header:
        cols = cols + col + ','
    cols = cols[:-1]

    cur.execute("CREATE TABLE IF NOT EXISTS " + tablename + " (" + cols + ");") 
    cur.executemany("INSERT INTO " + tablename + " (" + cols + ") VALUES (?);", data)
    con.commit()
    return

# Function to convert NoneType to empty string
def xstr(s):
    if s is None:
        return ''
    return str(s)

# Function to make API call
def api_call(request, params):
    full_url = base_url + request
    params['key'] = key
    response = requests.get(full_url, params=params)
    return response


'''
#Code to handle authentication.  Not currently implemented by Petfinder
def sig_hash(str_to_hash):
    sig_inputarr = bytearray(str_to_hash, 'utf-8')
    sig_outputarr = hashlib.md5(sig_inputarr)
    return sig_outputarr.hexdigest();

sig = sig_hash(secret + 'key=' + key)


full_url = base_url + 'auth.getToken'
params = {'key': key, 'sig': sig}
print('first url ' + full_url)
response = requests.get(full_url, params=params)
html = response.content

# Parse HTML response to get the Petfinder token
root = etree.fromstring(html)
parser = etree.HTMLParser()
tree = etree.fromstring(html, parser)
token_element = tree.xpath("//token")
token = token_element[0].text
'''

base_url = 'http://api.petfinder.com/'
key = '73a7bdb2d6fb6ff6fbf2ce0795109a58'
secret = '79e4470e7e285d7ff90d08b4939eb16d'

'''
# Make a pet.get call
pet_id = '31219564'
full_url = base_url + 'pet.get'
params = {'key': key, 'id': pet_id}
response = requests.get(full_url, params=params)
'''


# Create a connection to a sqlite db
con = sqlite3.connect(":memory:")
cur = con.cursor()
create_table('/Users/jonathan/Desktop/zip_code_database.csv', 't', con, cur)
cur.close()
con.close()

'''
# Make a shelter.find call
request = 'shelter.find'
location = '10013'
name = 'Animal Haven'
params = {'location': location, 'name': name}
response = api_call(request, params)

# Make a shelter.get call
# Ultimately this may not be needed, may only need shelter.find
request = 'shelter.get'
id = 'NY17'
params = {'id': id}
response = api_call(request, params)

# Get shelter ID from shelter.get output
root = etree.fromstring(response.content)
id_lst = root.xpath('//id')
id = id_lst[0].text

# Make a shelter.getPets call
request = 'shelter.getPets'
status = 'A'
params = {'id': id, 'status': status}
response = api_call(request, params)
'''
# Create pets table
con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute('CREATE TABLE pets (id, shelterID, shelterPetId, name, animal, breeds, mix, age, sex, size, options, lastUpdate, status)')


# Make a pet.find call
full_url = base_url + 'pet.find'
animal = 'dog'
location = '10016'
offset = 0
count = 2
params = {'key': key, 'animal': animal, 'location': location, 'offset': offset, 'count': count}
response = requests.get(full_url, params=params)

# Iterate through list of pets and prep for db insert
root = etree.fromstring(response.content)
pets = root.xpath('//pet')  # Returns a list with one entry per pet
data =[]
for pet in pets:
    field_list = ''
    row_data = []
    for field in pet.iterchildren():
        if field.tag != 'media' and field.tag != 'contact' and field.tag != 'description':
            field_list = field_list + ',' + field.tag
            #data = data + ',' + xstr(field.text)
            row_data.append(xstr(field.text))
    # Convert row_data to tuple and add it to data
    field_list = field_list[1:]
    data.append(tuple(row_data))

# Insert pet data into pets db
cur.executemany('INSERT INTO pets VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', data)
